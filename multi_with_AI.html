<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>칵테일 파티 보드</title>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #08192a, #3f5769);
      font-family: 'Montserrat', sans-serif;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .title {
      font-family: 'Cinzel', serif;
      font-size: 3em;
      margin-bottom: 20px;
      color: #FFFFFF;
      text-shadow: 0 0 1px #ffd700, 0 0 2px #ffd700, 0 0 4px #ffd700, 0 0 6px #ffd700;
    }
    @keyframes neonGlow {
      from {
        text-shadow: 0 0 5px #ffd700, 0 0 10px #ffd700, 0 0 20px #ffd700, 0 0 30px #ffd700, 0 0 40px #ffd700;
      }
      to {
        text-shadow: 0 0 20px #ffd700, 0 0 30px #ffd700, 0 0 40px #ffd700, 0 0 50px #ffd700, 0 0 60px #ffd700;
      }
    }
    .board {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      transform: scale(0.9);
      margin-bottom: 30px;
    }
    .row {
      display: flex;
      gap: 4px;
    }
    .slot {
      width: 85px;
      height: 105px;
      background-color: rgba(255, 255, 255, 0.15);
      display: flex;
      justify-content: center;
      align-items: center;
      border-radius: 5px;
      position: relative;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      transition: background-color 0.3s ease;
    }
    .slot.highlight {
      background-color: rgba(0, 255, 0, 0.3);
    }
    .slot.occupied {
      pointer-events: none;
    }
    .cocktail {
      width: 85px;
      height: 105px;
      cursor: grab;
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .cocktail.dragging {
      transform: scale(1.05);
      opacity: 0.8;
    }
    .cocktail.drop-animation {
      animation: dropPop 0.3s ease-out;
    }
    @keyframes dropPop {
      0% {
        transform: scale(1.2);
      }
      100% {
        transform: scale(1);
      }
    }
    .cocktail-container {
      background-color: rgba(255, 255, 255, 0.15);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 10px;
      padding: 15px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      margin-top: 20px;
      backdrop-filter: blur(8px);
    }
    .cocktail-pool {
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    /* 추가: 플레이어 영역 스타일 */
    #players-container {
      display: flex;
      gap: 20px;
      margin-top: 20px;
    }
    .player {
      text-align: center;
    }
    .active-player {
      border: 2px solid #ffd700;
      padding: 5px;
      border-radius: 5px;
    }
    #turn-indicator {
      margin-top: 20px;
      font-size: 1.2em;
    }
  </style>
</head>
<body>
  <h1 class="title">Cocktail Party</h1>
  <div class="board" id="board"></div>
  
  <div id="turn-indicator">현재 턴: Human</div>
  
  <div id="players-container">
    <div class="player active-player" id="player-human">
      <h2>Human</h2>
      <div class="cocktail-container">
        <div class="cocktail-pool" id="cocktail-pool-human"></div>
      </div>
    </div>
    <div class="player" id="player-ai1">
      <h2>AI 1</h2>
      <div class="cocktail-container">
        <div class="cocktail-pool" id="cocktail-pool-ai1"></div>
      </div>
    </div>
    <div class="player" id="player-ai2">
      <h2>AI 2</h2>
      <div class="cocktail-container">
        <div class="cocktail-pool" id="cocktail-pool-ai2"></div>
      </div>
    </div>
  </div>
  
  <script>
    const board = document.getElementById("board");
    const turnIndicator = document.getElementById("turn-indicator");
    const poolSize = 6; // 각 플레이어의 칵테일 바 크기
    let rows = [];
    let draggedCocktail = null;
    let dropSuccessful = false;
    let consecutivePasses = 0;
    
    // 전역 덱 생성: 총 36잔 (blue 7, red 7, green 7, yellow 7, pink 7, king 1)
    let deck = [];
    function initGlobalDeck() {
      deck = [];
      deck.push(...Array(7).fill("blue"));
      deck.push(...Array(7).fill("red"));
      deck.push(...Array(7).fill("green"));
      deck.push(...Array(7).fill("yellow"));
      deck.push(...Array(7).fill("pink"));
      deck.push("king");
      deck.sort(() => Math.random() - 0.5);
    }
    
    // 플레이어 객체 생성: human, ai1, ai2 각각 12잔 할당
    const players = [
      {
        id: 'human',
        type: 'human',
        deck: [],
        pool: [],
        poolElement: document.getElementById("cocktail-pool-human"),
        container: document.getElementById("player-human")
      },
      {
        id: 'ai1',
        type: 'ai',
        deck: [],
        pool: [],
        poolElement: document.getElementById("cocktail-pool-ai1"),
        container: document.getElementById("player-ai1")
      },
      {
        id: 'ai2',
        type: 'ai',
        deck: [],
        pool: [],
        poolElement: document.getElementById("cocktail-pool-ai2"),
        container: document.getElementById("player-ai2")
      }
    ];
    
    let currentPlayerIndex = 0;
    
    // 보드 생성: for문을 i = 8부터 -1까지, 각 행에 (8-i)개의 슬롯 추가
    function createBoard() {
      for (let i = 8; i > -1; i--) {
        let row = document.createElement("div");
        row.classList.add("row");
        for (let j = 0; j < 8 - i; j++) {
          let slot = document.createElement("div");
          slot.classList.add("slot");
          slot.dataset.empty = "true";
          slot.dataset.row = i;
          slot.dataset.col = j;
          row.appendChild(slot);
        }
        board.appendChild(row);
        rows[i] = row;
      }
    }
    
    // 플레이어별 칵테일 추가 함수
    function addNewCocktailToPlayer(player, cocktailType, isNew = false) {
      let cocktail = document.createElement("img");
      cocktail.src = `./images/${cocktailType}.png`;
      cocktail.classList.add("cocktail");
      cocktail.dataset.type = cocktailType;
      cocktail.draggable = (player.type === "human");
      
      if(isNew) {
        cocktail.style.opacity = "0";
        setTimeout(() => cocktail.style.opacity = "1", 50);
      }
      
      if(player.type === "human") {
        cocktail.addEventListener("dragstart", (e) => {
          // human의 경우에만 드래그 이벤트 처리
          e.dataTransfer.setData("text/plain", cocktailType);
          e.target.classList.add("dragging");
          draggedCocktail = cocktail;
          dropSuccessful = false;
          cocktail.originalParent = cocktail.parentElement;
          cocktail.originalIndex = Array.from(cocktail.parentElement.children).indexOf(cocktail);
          highlightValidSlots(cocktailType);
          setTimeout(() => {
            cocktail.style.visibility = "hidden";
          }, 0);
        });
      
        cocktail.addEventListener("dragend", (e) => {
          e.target.classList.remove("dragging");
          clearHighlights();
          if (!dropSuccessful) {
            e.target.style.visibility = "visible";
          }
        });
      }
      
      player.pool.push(cocktail);
      player.poolElement.appendChild(cocktail);
    }
    
    // 플레이어별 칵테일 풀 재정렬 및 FLIP 애니메이션 적용
    function refreshCocktailPoolForPlayer(player, gapIndex) {
      const previousPositions = new Map();
      player.pool.forEach(cocktail => {
        if (cocktail.parentElement === player.poolElement) {
          previousPositions.set(cocktail, cocktail.getBoundingClientRect());
        }
      });
      
      player.pool = player.pool.filter(c => c.parentElement === player.poolElement);
      player.poolElement.innerHTML = "";
      player.pool.forEach(cocktail => player.poolElement.appendChild(cocktail));
      while (player.pool.length < poolSize && player.deck.length > 0) {
        addNewCocktailToPlayer(player, player.deck.shift(), true);
      }
      
      player.pool.forEach((cocktail, index) => {
        if (cocktail.parentElement === player.poolElement && index >= gapIndex) {
          const newRect = cocktail.getBoundingClientRect();
          const prevRect = previousPositions.get(cocktail);
          if (prevRect) {
            const deltaX = prevRect.left - newRect.left;
            const deltaY = prevRect.top - newRect.top;
            if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
              cocktail.style.transition = 'none';
              cocktail.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
              requestAnimationFrame(() => {
                cocktail.style.transition = 'transform 0.3s ease';
                cocktail.style.transform = '';
              });
              cocktail.addEventListener('transitionend', function handler() {
                cocktail.style.transition = '';
                cocktail.removeEventListener('transitionend', handler);
              });
            }
          }
        }
      });
    }
    
    // 드래그 앤 드롭 이벤트: human 플레이어 전용
    document.addEventListener("dragover", (e) => {
      e.preventDefault();
    });
    
    document.addEventListener("drop", (e) => {
      // 현재 human 턴이 아닌 경우 무시
      if (players[currentPlayerIndex].type !== "human") return;
      
      e.preventDefault();
      clearHighlights();
      let slot = e.target;
      if (!slot.classList.contains("slot")) {
        slot = slot.closest(".slot");
      }
      if (slot && slot.classList.contains("slot") && slot.dataset.empty === "true") {
        let cocktailType = e.dataTransfer.getData("text/plain");
        if (isValidPlacement(slot, cocktailType)) {
          const gapIndex = draggedCocktail.originalIndex;
          if (draggedCocktail && draggedCocktail.originalParent.contains(draggedCocktail)) {
            draggedCocktail.originalParent.removeChild(draggedCocktail);
            let currentPlayer = players[currentPlayerIndex];
            currentPlayer.pool = currentPlayer.pool.filter(c => c !== draggedCocktail);
          }
          slot.appendChild(draggedCocktail);
          draggedCocktail.draggable = false;
          draggedCocktail.style.visibility = "visible";
          draggedCocktail.classList.add("drop-animation");
          draggedCocktail.addEventListener("animationend", function handler() {
            draggedCocktail.classList.remove("drop-animation");
            draggedCocktail.removeEventListener("animationend", handler);
          });
          slot.dataset.empty = "false";
          slot.classList.add("occupied");
          dropSuccessful = true;
          refreshCocktailPoolForPlayer(players[currentPlayerIndex], gapIndex);
          // move to next turn after human move
          setTimeout(() => nextTurn(), 300);
          draggedCocktail = null;
        }
      }
    });
    
    // 배치 가능 슬롯 하이라이트
    function highlightValidSlots(cocktailType) {
      const slots = board.querySelectorAll(".slot");
      slots.forEach(slot => {
        if (slot.dataset.empty === "true" && isValidPlacement(slot, cocktailType)) {
          slot.classList.add("highlight");
        } else {
          slot.classList.remove("highlight");
        }
      });
    }
    
    function clearHighlights() {
      const slots = board.querySelectorAll(".slot");
      slots.forEach(slot => slot.classList.remove("highlight"));
    }
    
    // 배치 가능 조건 함수 (기존과 동일)
    function isValidPlacement(slot, cocktailType) {
      let rowNumber = parseInt(slot.dataset.row);
      let col = parseInt(slot.dataset.col);
      if (rowNumber === 0) return true;
      
      let supportRow = rows[rowNumber - 1];
      if (!supportRow) return false;
      
      let leftSlot = supportRow.children[col];
      let rightSlot = supportRow.children[col + 1];
      
      if (!leftSlot || leftSlot.dataset.empty === "true" ||
          !rightSlot || rightSlot.dataset.empty === "true") {
        return false;
      }
      
      let leftType = leftSlot.firstChild ? leftSlot.firstChild.dataset.type : null;
      let rightType = rightSlot.firstChild ? rightSlot.firstChild.dataset.type : null;
      
      if (leftType === "king" || rightType === "king") {
        return false;
      }
      
      if (cocktailType === "king") {
        return true;
      } else {
        return (leftType === cocktailType || rightType === cocktailType);
      }
    }
    
    // AI 턴 처리
    function aiTurn(player) {
      let moveMade = false;
      let usedCocktailIndex = null;
      for (let i = 0; i < player.pool.length; i++) {
        let cocktail = player.pool[i];
        let cocktailType = cocktail.dataset.type;
        const slots = board.querySelectorAll(".slot");
        for (let slot of slots) {
          if (slot.dataset.empty === "true" && isValidPlacement(slot, cocktailType)) {
            usedCocktailIndex = i;
            player.poolElement.removeChild(cocktail);
            player.pool.splice(i, 1);
            slot.appendChild(cocktail);
            cocktail.draggable = false;
            cocktail.classList.add("drop-animation");
            slot.dataset.empty = "false";
            slot.classList.add("occupied");
            moveMade = true;
            break;
          }
        }
        if (moveMade) break;
      }
      if (moveMade) {
        refreshCocktailPoolForPlayer(player, usedCocktailIndex !== null ? usedCocktailIndex : 0);
      }
      nextTurn();
    }
    
    // 각 플레이어가 유효한 이동을 할 수 있는지 검사
    function canPlayerMakeMove(player) {
      const slots = board.querySelectorAll(".slot");
      for (let cocktail of player.pool) {
        for (let slot of slots) {
          if (slot.dataset.empty === "true" && isValidPlacement(slot, cocktail.dataset.type)) {
            return true;
          }
        }
      }
      return false;
    }
    
    // 턴 전환 및 시작
    function startTurn() {
      const currentPlayer = players[currentPlayerIndex];
      // UI 업데이트: active player 강조 및 턴 표시
      players.forEach(p => p.container.classList.remove("active-player"));
      currentPlayer.container.classList.add("active-player");
      turnIndicator.textContent = "현재 턴: " + (currentPlayer.type === "human" ? "Human" : currentPlayer.id.toUpperCase());
      
      if (!canPlayerMakeMove(currentPlayer)) {
        consecutivePasses++;
        setTimeout(() => {
          nextTurn();
        }, 1000);
        return;
      } else {
        consecutivePasses = 0;
      }
      
      if (currentPlayer.type === "ai") {
        setTimeout(() => {
          aiTurn(currentPlayer);
        }, 1000);
      }
      // human은 드래그 앤 드롭을 통해 행동하므로 별도 처리 없음
    }
    
    function nextTurn() {
      if (consecutivePasses >= players.length) {
        alert("모든 플레이어가 이동할 수 없습니다. 게임 종료!");
        return;
      }
      currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
      startTurn();
    }
    
    // 게임 초기화
    function initGame() {
      initGlobalDeck();
      createBoard();
      // 분배: 각 플레이어에게 12잔씩 할당
      players.forEach(player => {
        player.deck = deck.splice(0, 12);
        // 초기 칵테일 풀 채우기 (poolSize개)
        while (player.pool.length < poolSize && player.deck.length > 0) {
          addNewCocktailToPlayer(player, player.deck.shift(), true);
        }
      });
      startTurn();
    }
    
    initGame();
  </script>
</body>
</html>
