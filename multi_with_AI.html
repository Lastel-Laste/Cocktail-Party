<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>칵테일 파티 보드</title>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #08192a, #3f5769);
      font-family: 'Montserrat', sans-serif;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      overflow: hidden;
      transform: scale(0.75);
      transform-origin: top center;
    }
    .title {
      font-family: 'Cinzel', serif;
      font-size: 3em;
      margin-bottom: 20px;
      color: #FFFFFF;
      text-shadow: 0 0 1px #ffd700, 0 0 2px #ffd700, 0 0 4px #ffd700, 0 0 6px #ffd700;
    }
    .board {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      margin-bottom: 60px;
    }
    .row {
      display: flex;
      gap: 4px;
    }
    .slot {
      width: 85px;
      height: 105px;
      background-color: rgba(255, 255, 255, 0.15);
      display: flex;
      justify-content: center;
      align-items: center;
      border-radius: 5px;
      position: relative;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      transition: background-color 0.3s ease;
    }
    .slot.highlight {
      background-color: rgba(0, 255, 0, 0.3);
    }
    .slot.occupied {
      pointer-events: none;
    }
    .cocktail {
      width: 85px;
      height: 105px;
      cursor: grab;
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .cocktail.dragging {
      transform: scale(1.05);
      opacity: 0.8;
    }
    .cocktail.drop-animation {
      animation: dropPop 0.3s ease-out;
    }
    @keyframes dropPop {
      0% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    .cocktail-container {
      background-color: rgba(255, 255, 255, 0.15);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 10px;
      padding: 15px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      margin-top: 20px;
      backdrop-filter: blur(8px);
    }
    .cocktail-pool {
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    /* 플레이어 영역 스타일 */
    #players-container {
      display: flex;
      gap: 20px;
      margin-top: 10px;
    }
    .player {
      text-align: center;
      top: -50px;
    }
    .active-player {
      padding: 5px;
      border-radius: 5px;
      box-shadow: 0 0 10px 2px #ffd700;
    }
    #turn-indicator {
      margin-top: -50px;
      font-size: 1.2em;
    }
    /* 점수판 스타일 */
    #score-board {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <audio id="bgm" src="./audio/Color_Scammer.mp3" loop></audio>
  <h1 class="title">Cocktail Party</h1>
  <div class="board" id="board"></div>
  
  <!-- 초기 턴 인디케이터: "You" 표시 -->
  <div id="turn-indicator">라운드 1 - 현재 턴: You</div>
  
  <div id="players-container">
    <div class="player" id="player-ai1">
      <h2>AI 1</h2>
      <div class="cocktail-container">
        <div class="cocktail-pool" id="cocktail-pool-ai1"></div>
      </div>
    </div>
    <div class="player active-player" id="player-human">
      <h2>You</h2>
      <div class="cocktail-container">
        <div class="cocktail-pool" id="cocktail-pool-human"></div>
      </div>
    </div>
    <div class="player" id="player-ai2">
      <h2>AI 2</h2>
      <div class="cocktail-container">
        <div class="cocktail-pool" id="cocktail-pool-ai2"></div>
      </div>
    </div>
  </div>
  
  <!-- 점수판 -->
  <div id="score-board">
    <h3>Score Board</h3>
    <ul id="score-list"></ul>
  </div>
  
  <script>
    // BGM 자동 재생 및 볼륨 조절
    document.addEventListener('click', function startBGM() {
      const bgm = document.getElementById('bgm');
      bgm.volume = 0.3;
      if (bgm.paused) {
        bgm.play().catch(err => console.log("BGM play error: ", err));
      }
      document.removeEventListener('click', startBGM);
    });
    
    const board = document.getElementById("board");
    const turnIndicator = document.getElementById("turn-indicator");
    const poolSize = 6;
    let rows = [];
    let draggedCocktail = null;
    // consecutivePasses 변수 제거
    
    // 라운드 변수
    let currentRound = 1;
    const totalRounds = 3;
    
    // 전역 덱 생성: 총 36잔 (blue 7, red 7, green 7, yellow 7, pink 7, king 1)
    let deck = [];
    function initGlobalDeck() {
      deck = [];
      deck.push(...Array(7).fill("blue"));
      deck.push(...Array(7).fill("red"));
      deck.push(...Array(7).fill("green"));
      deck.push(...Array(7).fill("yellow"));
      deck.push(...Array(7).fill("pink"));
      deck.push("king");
      deck.sort(() => Math.random() - 0.5);
    }
    
    // 플레이어 객체 (내부 id와 type은 그대로 유지)
    const players = [
      {
        id: 'human',
        type: 'human',
        deck: [],
        pool: [],
        poolElement: document.getElementById("cocktail-pool-human"),
        container: document.getElementById("player-human"),
        score: 36
      },
      {
        id: 'ai1',
        type: 'ai',
        deck: [],
        pool: [],
        poolElement: document.getElementById("cocktail-pool-ai1"),
        container: document.getElementById("player-ai1"),
        score: 36
      },
      {
        id: 'ai2',
        type: 'ai',
        deck: [],
        pool: [],
        poolElement: document.getElementById("cocktail-pool-ai2"),
        container: document.getElementById("player-ai2"),
        score: 36
      }
    ];
    
    let currentPlayerIndex = 0;
    
    // 보드 생성
    function createBoard() {
      for (let i = 8; i > -1; i--) {
        let row = document.createElement("div");
        row.classList.add("row");
        for (let j = 0; j < 8 - i; j++) {
          let slot = document.createElement("div");
          slot.classList.add("slot");
          slot.dataset.empty = "true";
          slot.dataset.row = i;
          slot.dataset.col = j;
          row.appendChild(slot);
        }
        board.appendChild(row);
        rows[i] = row;
      }
    }
    
    // 보드 초기화
    function clearBoard() {
      board.innerHTML = "";
      rows = [];
      createBoard();
    }
    
    // 점수판 업데이트 (내부 id가 "human"이면 "YOU"로 표시)
    function updateScoreBoard() {
      const scoreList = document.getElementById("score-list");
      let scoreHTML = "";
      players.forEach(player => {
        const name = (player.id.toLowerCase() === "human") ? "YOU" : player.id.toUpperCase();
        scoreHTML += `<li>${name}: ${player.score}</li>`;
      });
      scoreList.innerHTML = scoreHTML;
    }
    
    // 플레이어별 칵테일 추가
    function addNewCocktailToPlayer(player, cocktailType, isNew = false) {
      let cocktail = document.createElement("img");
      cocktail.src = `./images/${cocktailType}.png`;
      cocktail.classList.add("cocktail");
      cocktail.dataset.type = cocktailType;
      cocktail.draggable = (player.type === "human");
      
      if(isNew) {
        cocktail.style.opacity = "0";
        setTimeout(() => cocktail.style.opacity = "1", 50);
      }
      
      if(player.type === "human") {
        cocktail.addEventListener("dragstart", (e) => {
          e.dataTransfer.setData("text/plain", cocktailType);
          e.target.classList.add("dragging");
          draggedCocktail = cocktail;
          // 칵테일 배치 가능 슬롯 하이라이트
          highlightValidSlots(cocktailType);
          cocktail.originalParent = cocktail.parentElement;
          cocktail.originalIndex = Array.from(cocktail.parentElement.children).indexOf(cocktail);
          setTimeout(() => {
            cocktail.style.visibility = "hidden";
          }, 0);
        });
      
        cocktail.addEventListener("dragend", (e) => {
          e.target.classList.remove("dragging");
          clearHighlights();
          if (!draggedCocktail) return;
          e.target.style.visibility = "visible";
        });
      }
      
      player.pool.push(cocktail);
      player.poolElement.appendChild(cocktail);
    }
    
    // 칵테일 풀 재정렬 및 FLIP 애니메이션
    function refreshCocktailPoolForPlayer(player, gapIndex) {
      const previousPositions = new Map();
      player.pool.forEach(cocktail => {
        if (cocktail.parentElement === player.poolElement) {
          previousPositions.set(cocktail, cocktail.getBoundingClientRect());
        }
      });
      
      player.pool = player.pool.filter(c => c.parentElement === player.poolElement);
      player.poolElement.innerHTML = "";
      player.pool.forEach(cocktail => player.poolElement.appendChild(cocktail));
      while (player.pool.length < poolSize && player.deck.length > 0) {
        addNewCocktailToPlayer(player, player.deck.shift(), true);
      }
      
      player.pool.forEach((cocktail, index) => {
        if (cocktail.parentElement === player.poolElement && index >= gapIndex) {
          const newRect = cocktail.getBoundingClientRect();
          const prevRect = previousPositions.get(cocktail);
          if (prevRect) {
            const deltaX = prevRect.left - newRect.left;
            const deltaY = prevRect.top - newRect.top;
            if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
              cocktail.style.transition = 'none';
              cocktail.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
              requestAnimationFrame(() => {
                cocktail.style.transition = 'transform 0.3s ease';
                cocktail.style.transform = '';
              });
              cocktail.addEventListener('transitionend', function handler() {
                cocktail.style.transition = '';
                cocktail.removeEventListener('transitionend', handler);
              });
            }
          }
        }
      });
    }
    
    // 드래그 앤 드롭 이벤트
    document.addEventListener("dragover", (e) => {
      e.preventDefault();
    });
    
    document.addEventListener("drop", (e) => {
      if (players[currentPlayerIndex].type !== "human") return;
      e.preventDefault();
      clearHighlights();
      let slot = e.target;
      if (!slot.classList.contains("slot")) {
        slot = slot.closest(".slot");
      }
      if (slot && slot.classList.contains("slot") && slot.dataset.empty === "true") {
        let cocktailType = e.dataTransfer.getData("text/plain");
        if (isValidPlacement(slot, cocktailType)) {
          const gapIndex = draggedCocktail.originalIndex;
          if (draggedCocktail && draggedCocktail.originalParent.contains(draggedCocktail)) {
            draggedCocktail.originalParent.removeChild(draggedCocktail);
            let currentPlayer = players[currentPlayerIndex];
            currentPlayer.pool = currentPlayer.pool.filter(c => c !== draggedCocktail);
            const randomNum = Math.floor(Math.random() * 4) + 1;
            const seDrop = new Audio(`./audio/drop${randomNum}.mp3`);
            seDrop.volume = 1.0;
            seDrop.play().catch(err => console.log("Drop sound play error:", err));
          }
          slot.appendChild(draggedCocktail);
          draggedCocktail.draggable = false;
          draggedCocktail.style.visibility = "visible";
          draggedCocktail.classList.add("drop-animation");
          draggedCocktail.addEventListener("animationend", function handler() {
            this.classList.remove("drop-animation");
            this.removeEventListener("animationend", handler);
          });
          slot.dataset.empty = "false";
          slot.classList.add("occupied");
          refreshCocktailPoolForPlayer(players[currentPlayerIndex], gapIndex);
          setTimeout(() => nextTurn(), 300);
          draggedCocktail = null;
          return;
        }
      }
      // 잘못된 드롭이면 wrong 효과음 재생
      let seWrong = new Audio('./audio/wrong.mp3');
      seWrong.volume = 1.0;
      seWrong.play().catch(err => console.log("Wrong sound play error:", err));
    });
    
    // 슬롯 하이라이트
    function highlightValidSlots(cocktailType) {
      const slots = board.querySelectorAll(".slot");
      slots.forEach(slot => {
        if (slot.dataset.empty === "true" && isValidPlacement(slot, cocktailType)) {
          slot.classList.add("highlight");
        } else {
          slot.classList.remove("highlight");
        }
      });
    }
    
    function clearHighlights() {
      const slots = board.querySelectorAll(".slot");
      slots.forEach(slot => slot.classList.remove("highlight"));
    }
    
    // 배치 가능 조건 함수 (기존 로직 유지)
    function isValidPlacement(slot, cocktailType) {
      let rowNumber = parseInt(slot.dataset.row);
      let col = parseInt(slot.dataset.col);
      if (rowNumber === 0) return true;
      
      let supportRow = rows[rowNumber - 1];
      if (!supportRow) return false;
      
      let leftSlot = supportRow.children[col];
      let rightSlot = supportRow.children[col + 1];
      
      if (!leftSlot || leftSlot.dataset.empty === "true" ||
          !rightSlot || rightSlot.dataset.empty === "true") {
        return false;
      }
      
      let leftType = leftSlot.firstChild ? leftSlot.firstChild.dataset.type : null;
      let rightType = rightSlot.firstChild ? rightSlot.firstChild.dataset.type : null;
      
      if (leftType === "king" || rightType === "king") {
        return false;
      }
      
      if (cocktailType === "king") {
        return true;
      } else {
        return (leftType === cocktailType || rightType === cocktailType);
      }
    }
    
    // 턴 시작: 현재 플레이어에게 턴을 부여
    function startTurn() {
      const currentPlayer = players[currentPlayerIndex];
      players.forEach(p => p.container.classList.remove("active-player"));
      currentPlayer.container.classList.add("active-player");
      const displayName = (currentPlayer.id.toLowerCase() === "human") ? "You" : currentPlayer.id.toUpperCase();
      turnIndicator.textContent = `라운드 ${currentRound} - 현재 턴: ${displayName}`;
      
      // AI 턴이면 AI 행동 실행, 인간이면 드래그 활성화
      if (currentPlayer.type === "ai") {
        setTimeout(() => {
          aiTurn(currentPlayer);
        }, 1000);
        disableDragForHuman();
      } else {
        enableDragForHuman();
      }
    }
    
    // nextTurn: 현재 턴 이후부터 순환하며 칵테일을 둘 수 있는 플레이어를 찾아 턴을 넘김
    function nextTurn() {
      let found = false;
      for (let j = 1; j <= players.length; j++) {
        let i = (currentPlayerIndex + j) % players.length;
        if (canPlayerMakeMove(players[i])) {
          currentPlayerIndex = i;
          found = true;
          break;
        }
      }
      if (!found) {
        endRound();
      } else {
        startTurn();
      }
    }
    
    // AI 턴 처리
    function aiTurn(player) {
      let moveMade = false;
      let usedCocktailIndex = null;
      for (let i = 0; i < player.pool.length; i++) {
        let cocktail = player.pool[i];
        let cocktailType = cocktail.dataset.type;
        const slots = board.querySelectorAll(".slot");
        for (let slot of slots) {
          if (slot.dataset.empty === "true" && isValidPlacement(slot, cocktailType)) {
            usedCocktailIndex = i;
            player.poolElement.removeChild(cocktail);
            player.pool.splice(i, 1);
            slot.appendChild(cocktail);
            cocktail.draggable = false;
            cocktail.classList.add("drop-animation");
            slot.dataset.empty = "false";
            slot.classList.add("occupied");
            moveMade = true;
            break;
          }
        }
        if (moveMade) break;
      }
      if (moveMade) {
        refreshCocktailPoolForPlayer(player, usedCocktailIndex !== null ? usedCocktailIndex : 0);
      }
      nextTurn();
    }
    
    // 플레이어가 유효한 이동을 할 수 있는지 검사
    function canPlayerMakeMove(player) {
      const slots = board.querySelectorAll(".slot");
      for (let cocktail of player.pool) {
        for (let slot of slots) {
          if (slot.dataset.empty === "true" && isValidPlacement(slot, cocktail.dataset.type)) {
            return true;
          }
        }
      }
      return false;
    }
    
    function disableDragForHuman() {
      const humanCocktails = document.querySelectorAll("#cocktail-pool-human .cocktail");
      humanCocktails.forEach(cocktail => {
        cocktail.draggable = false;
      });
    }
    
    function enableDragForHuman() {
      const humanCocktails = document.querySelectorAll("#cocktail-pool-human .cocktail");
      humanCocktails.forEach(cocktail => {
        cocktail.draggable = true;
      });
    }
    
    // 라운드 시작: 첫 라운드는 효과음 없이, 이후 라운드 시작 시 효과음 재생
    function startRound() {
      clearBoard();
      initGlobalDeck();
      
      players.forEach(player => {
        player.pool = [];
        player.poolElement.innerHTML = "";
        player.deck = deck.splice(0, 12);
        while (player.pool.length < poolSize && player.deck.length > 0) {
          addNewCocktailToPlayer(player, player.deck.shift(), true);
        }
      });
      
      currentPlayerIndex = 0;
      if (currentRound > 1) {
        let startSoundFile = Math.random() < 0.5 ? 'roundstart1.mp3' : 'roundstart2.mp3';
        let seRoundStart = new Audio(`./audio/${startSoundFile}`);
        seRoundStart.volume = 1.0;
        seRoundStart.play().catch(err => console.log("Round start sound error:", err));
      }
      // 첫 라운드 인디케이터는 이미 "You"로 표시됨
      const displayName = (players[currentPlayerIndex].id.toLowerCase() === "human") ? "You" : players[currentPlayerIndex].id.toUpperCase();
      turnIndicator.textContent = `라운드 ${currentRound} - 현재 턴: ${displayName}`;
      startTurn();
    }
    
    // 라운드 종료: roundend 효과음, 점수 감점, 점수판 업데이트, 플레이어 재정렬
    function endRound() {
      let seRoundEnd = new Audio('./audio/roundend.mp3');
      seRoundEnd.volume = 1.0;
      seRoundEnd.play().catch(err => console.log("Round end sound error:", err));
      
      players.forEach(player => {
        player.score -= player.pool.length;
      });
      updateScoreBoard();
      
      players.sort((a, b) => b.score - a.score);
      
      if (currentRound >= totalRounds) {
        setTimeout(() => {
          const winnerName = (players[0].id.toLowerCase() === "human") ? "YOU" : players[0].id.toUpperCase();
          alert("게임 종료! 1등 플레이어: " + winnerName);
        }, 500);
      } else {
        currentRound++;
        setTimeout(() => {
          startRound();
        }, 1500);
      }
    }
    
    // 게임 초기화
    function initGame() {
      updateScoreBoard();
      startRound();
    }
    
    initGame();
  </script>
</body>
</html>
